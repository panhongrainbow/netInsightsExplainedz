# net function of interaction

> Here we mainly discuss the interaction between C language and Golang net functions.

## Golang calls glibc

### Pros:

`Mature and stable`

Glibc has been used in Linux for over 30 years and provides a stable and efficient network interface and implementation.

Golang can directly utilize these mature functions.

### Cons:

`Performance overhead`

Multi-level abstraction brings a certain performance overhead. Calling glibc's net package does not have the highest performance like using system calls directly.

## List all possible functions

There are some important functions that call glibc.

| functions     | descriptions                                                 |
| ------------- | ------------------------------------------------------------ |
| `socket`      | Golang uses glibc's socket() system call to `create TCP or UDP sockets`. |
| `bind`        | Used to associate a socket `with an IP address and port number`.<br />Golang calls glibc's bind(). |
| `connect`     | Used to `initiate a connection` from a TCP client socket.<br />Golang uses glibc's connect() system call. |
| `accept`      | `Accepts incoming TCP connection` requests. Golang calls glibc's accept4(). |
| `send/recv`   | Golang uses glibc's send() and recv() to send and receive TCP or UDP data. |
| `select`      | Golang implements the `select statement` using glibc's pselect() and ppoll() to implement I/O multiplexing. |
| `getaddrinfo` | Golang uses glibc's getaddrinfo() to `resolve IP addresses and hostnames`. |
| `others`      | Golang's `net/http, net/smtp, net/dns` and other packages also rely on glibc to interact with the operating system and network communication |

## Dynamic linking and Static linking

### Static linking

#### Pros

Statically linked programs have no external dependencies, so the programs can be `executed anywhere`.

Any update to libraries requires `recompiling` the applications that rely on them.

#### Cons

Since each program has its own copy of the libraries it needs, static linking `consumes more space`.

### Dynamic linking

#### Pros

If glibc has vulnerabilities, upgrading glibc itself can `fix these vulnerabilities quickly`.

#### Cons

If a shared library has `vulnerabilities`, all programs that use it are at risk.

(2024/4/16)

## Dynamic linking and Static linking in Golang

### Explaination

Golang programs and `standard golang libraries` (including the net package) are `statically linked by default`.

When calling the external C library `glibc` through cgo, `dynamic linking` of glibc is used by default if not specified.

The net package can call glibc through `cgo`, but the `net package` itself is still `statically linked`.

### Comparison

Compare the executable file sizes after dynamic linking compilation and static linking compilation.

```bash
$ make normal
# go build ./socket.go
# -rwxr-xr-x 1 panhong panhong 1.3M  4月 17 18:05 socket # <<<<< <<<<< <<<<< socket size is 1.3M
# -rw-r--r-- 1 panhong panhong  337  4月 17 13:34 socket.go

$ make include
# go build -ldflags "-linkmode external -extldflags -static" ./socket.go
# -rwxr-xr-x 1 panhong panhong 2.3M  4月 17 18:06 socket # <<<<< <<<<< <<<<< socket size is 2.3M
# -rw-r--r-- 1 panhong panhong  337  4月 17 13:34 socket.go
```

The sizes after compilation are 1.3M and 2.3M respectively. The executable file generated by `statically linking glibc is larger`.

### Strace glibc

Use strace to trace the socket function to find the link to glibc

```bash
$ make strace
# go build -ldflags "-linkmode external -extldflags -static" ./socket.go
# strace ./socket
# execve("./socket", ["./socket"], 0x7fff19b539d0 /* 63 vars */) = 0
# brk(NULL)                               = 0xaf3000
# brk(0xaf3dc0)                           = 0xaf3dc0
# arch_prctl(ARCH_SET_FS, 0xaf33c0)       = 0
# uname({sysname="Linux", nodename="debian5", ...}) = 0
# ...
# ...
# rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0
# rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
# socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3 # <<<<< <<<<< <<<<< call glibc !
# write(2, "3", 13)                        = 1
# write(2, "\n", 1
# )                       = 1
# exit_group(0)                           = ?
# +++ exited with 0 +++
```

Search the socket function in glibc

```bash
$ cat /usr/include/x86_64-linux-gnu/sys/socket.h | grep 'socket ('
# extern int socket (int __domain, int __type, int __protocol) __THROW;
```

## Check glibc version 

```bash
$ ldd /bin/bash
#        linux-vdso.so.1 (0x00007ffd98fa0000)
#        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007ff6796a7000)
#        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff6796a1000)
#        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff6794c8000)
#        /lib64/ld-linux-x86-64.so.2 (0x00007ff679837000)

$ ldd --version
# ldd (Debian GLIBC 2.33-7) 2.33 # <<<<< <<<<< <<<<< glibc 2.33 version
```

(2024/4/17)
